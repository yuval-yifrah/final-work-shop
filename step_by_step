# Status Page AWS Implementation Guide

## Prerequisites

### AWS Account Setup
- [ ] Create AWS account
- [ ] Set up billing alerts at $250 and $300
- [ ] Enable MFA on root account
- [ ] Create IAM user for daily operations
- [ ] Install AWS CLI v2
- [ ] Configure AWS CLI with access keys

### Domain and DNS
- [ ] Purchase domain name (recommend Namecheap, ~$12/year)
- [ ] Create Route 53 hosted zone
- [ ] Update nameservers at domain registrar
- [ ] Choose primary AWS region: us-east-1 (recommended for cost)

---

## Phase 1: Network Infrastructure (Day 1, 2-3 hours)

### Step 1.1: Create VPC and Subnets
```bash
# Set variables
export AWS_REGION=us-east-1
export VPC_NAME=StatusPage-VPC

# Create VPC
VPC_ID=$(aws ec2 create-vpc \
    --cidr-block 10.0.0.0/16 \
    --tag-specifications "ResourceType=vpc,Tags=[{Key=Name,Value=$VPC_NAME}]" \
    --query 'Vpc.VpcId' --output text)
echo "VPC ID: $VPC_ID"

# Enable DNS hostnames
aws ec2 modify-vpc-attribute --vpc-id $VPC_ID --enable-dns-hostnames

# Create Internet Gateway
IGW_ID=$(aws ec2 create-internet-gateway \
    --tag-specifications "ResourceType=internet-gateway,Tags=[{Key=Name,Value=$VPC_NAME-IGW}]" \
    --query 'InternetGateway.InternetGatewayId' --output text)
echo "Internet Gateway ID: $IGW_ID"

# Attach IGW to VPC
aws ec2 attach-internet-gateway --vpc-id $VPC_ID --internet-gateway-id $IGW_ID

# Create Public Subnet
PUBLIC_SUBNET_ID=$(aws ec2 create-subnet \
    --vpc-id $VPC_ID \
    --cidr-block 10.0.1.0/24 \
    --availability-zone us-east-1a \
    --tag-specifications "ResourceType=subnet,Tags=[{Key=Name,Value=$VPC_NAME-Public-1a}]" \
    --query 'Subnet.SubnetId' --output text)
echo "Public Subnet ID: $PUBLIC_SUBNET_ID"

# Create Private Subnet 1
PRIVATE_SUBNET_1_ID=$(aws ec2 create-subnet \
    --vpc-id $VPC_ID \
    --cidr-block 10.0.2.0/24 \
    --availability-zone us-east-1a \
    --tag-specifications "ResourceType=subnet,Tags=[{Key=Name,Value=$VPC_NAME-Private-1a}]" \
    --query 'Subnet.SubnetId' --output text)
echo "Private Subnet 1 ID: $PRIVATE_SUBNET_1_ID"

# Create Private Subnet 2 (for Multi-AZ RDS)
PRIVATE_SUBNET_2_ID=$(aws ec2 create-subnet \
    --vpc-id $VPC_ID \
    --cidr-block 10.0.3.0/24 \
    --availability-zone us-east-1b \
    --tag-specifications "ResourceType=subnet,Tags=[{Key=Name,Value=$VPC_NAME-Private-1b}]" \
    --query 'Subnet.SubnetId' --output text)
echo "Private Subnet 2 ID: $PRIVATE_SUBNET_2_ID"
```

### Step 1.2: Create NAT Gateway
```bash
# Allocate Elastic IP for NAT Gateway
EIP_ALLOC_ID=$(aws ec2 allocate-address \
    --domain vpc \
    --tag-specifications "ResourceType=elastic-ip,Tags=[{Key=Name,Value=$VPC_NAME-NAT-EIP}]" \
    --query 'AllocationId' --output text)
echo "EIP Allocation ID: $EIP_ALLOC_ID"

# Create NAT Gateway
NAT_GW_ID=$(aws ec2 create-nat-gateway \
    --subnet-id $PUBLIC_SUBNET_ID \
    --allocation-id $EIP_ALLOC_ID \
    --tag-specifications "ResourceType=nat-gateway,Tags=[{Key=Name,Value=$VPC_NAME-NAT}]" \
    --query 'NatGateway.NatGatewayId' --output text)
echo "NAT Gateway ID: $NAT_GW_ID"

# Wait for NAT Gateway to be available
aws ec2 wait nat-gateway-available --nat-gateway-ids $NAT_GW_ID
```

### Step 1.3: Create Route Tables
```bash
# Create Public Route Table
PUBLIC_RT_ID=$(aws ec2 create-route-table \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=route-table,Tags=[{Key=Name,Value=$VPC_NAME-Public-RT}]" \
    --query 'RouteTable.RouteTableId' --output text)
echo "Public Route Table ID: $PUBLIC_RT_ID"

# Create Private Route Table
PRIVATE_RT_ID=$(aws ec2 create-route-table \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=route-table,Tags=[{Key=Name,Value=$VPC_NAME-Private-RT}]" \
    --query 'RouteTable.RouteTableId' --output text)
echo "Private Route Table ID: $PRIVATE_RT_ID"

# Add routes
aws ec2 create-route --route-table-id $PUBLIC_RT_ID --destination-cidr-block 0.0.0.0/0 --gateway-id $IGW_ID
aws ec2 create-route --route-table-id $PRIVATE_RT_ID --destination-cidr-block 0.0.0.0/0 --nat-gateway-id $NAT_GW_ID

# Associate subnets with route tables
aws ec2 associate-route-table --subnet-id $PUBLIC_SUBNET_ID --route-table-id $PUBLIC_RT_ID
aws ec2 associate-route-table --subnet-id $PRIVATE_SUBNET_1_ID --route-table-id $PRIVATE_RT_ID
aws ec2 associate-route-table --subnet-id $PRIVATE_SUBNET_2_ID --route-table-id $PRIVATE_RT_ID
```

### Step 1.4: Create Security Groups
```bash
# ALB Security Group
ALB_SG_ID=$(aws ec2 create-security-group \
    --group-name ALB-SG \
    --description "Application Load Balancer Security Group" \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=ALB-SG}]" \
    --query 'GroupId' --output text)
echo "ALB Security Group ID: $ALB_SG_ID"

# EC2 Security Group
EC2_SG_ID=$(aws ec2 create-security-group \
    --group-name EC2-SG \
    --description "EC2 Application Server Security Group" \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=EC2-SG}]" \
    --query 'GroupId' --output text)
echo "EC2 Security Group ID: $EC2_SG_ID"

# RDS Security Group
RDS_SG_ID=$(aws ec2 create-security-group \
    --group-name RDS-SG \
    --description "RDS Database Security Group" \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=RDS-SG}]" \
    --query 'GroupId' --output text)
echo "RDS Security Group ID: $RDS_SG_ID"

# Redis Security Group
REDIS_SG_ID=$(aws ec2 create-security-group \
    --group-name Redis-SG \
    --description "ElastiCache Redis Security Group" \
    --vpc-id $VPC_ID \
    --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=Redis-SG}]" \
    --query 'GroupId' --output text)
echo "Redis Security Group ID: $REDIS_SG_ID"

# Configure Security Group Rules
aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress --group-id $EC2_SG_ID --protocol tcp --port 8000 --source-group $ALB_SG_ID
aws ec2 authorize-security-group-ingress --group-id $EC2_SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress --group-id $RDS_SG_ID --protocol tcp --port 5432 --source-group $EC2_SG_ID
aws ec2 authorize-security-group-ingress --group-id $REDIS_SG_ID --protocol tcp --port 6379 --source-group $EC2_SG_ID
```

**Checkpoint 1**: Network infrastructure complete. Cost: $32/month (NAT Gateway)

---

## Phase 2: Database and Cache Setup (Day 2, 1 hour)

### Step 2.1: Create RDS Subnet Group
```bash
aws rds create-db-subnet-group \
    --db-subnet-group-name statuspage-subnet-group \
    --db-subnet-group-description "StatusPage RDS Subnet Group" \
    --subnet-ids $PRIVATE_SUBNET_1_ID $PRIVATE_SUBNET_2_ID \
    --tags Key=Name,Value=StatusPage-DB-SubnetGroup
```

### Step 2.2: Create RDS PostgreSQL Instance
```bash
# Generate secure password
DB_PASSWORD=$(openssl rand -base64 32)
echo "Database Password: $DB_PASSWORD" # Save this securely!

# Create RDS instance
aws rds create-db-instance \
    --db-instance-identifier statuspage-db \
    --db-instance-class db.t3.micro \
    --engine postgres \
    --engine-version 14.9 \
    --master-username statuspage_admin \
    --master-user-password "$DB_PASSWORD" \
    --allocated-storage 20 \
    --storage-type gp2 \
    --vpc-security-group-ids $RDS_SG_ID \
    --db-subnet-group-name statuspage-subnet-group \
    --db-name statuspage \
    --backup-retention-period 7 \
    --multi-az \
    --storage-encrypted \
    --tags Key=Name,Value=StatusPage-DB
```

### Step 2.3: Create ElastiCache Subnet Group and Redis
```bash
# Create ElastiCache subnet group
aws elasticache create-cache-subnet-group \
    --cache-subnet-group-name statuspage-redis-subnet \
    --cache-subnet-group-description "StatusPage Redis Subnet Group" \
    --subnet-ids $PRIVATE_SUBNET_1_ID $PRIVATE_SUBNET_2_ID

# Create Redis cluster
aws elasticache create-cache-cluster \
    --cache-cluster-id statuspage-redis \
    --cache-node-type cache.t3.micro \
    --engine redis \
    --engine-version 7.0 \
    --num-cache-nodes 1 \
    --security-group-ids $REDIS_SG_ID \
    --cache-subnet-group-name statuspage-redis-subnet \
    --tags Key=Name,Value=StatusPage-Redis
```

### Step 2.4: Store Configuration in Parameter Store
```bash
# Wait for RDS to be available
aws rds wait db-instance-available --db-instance-identifier statuspage-db

# Get RDS endpoint
RDS_ENDPOINT=$(aws rds describe-db-instances \
    --db-instance-identifier statuspage-db \
    --query 'DBInstances[0].Endpoint.Address' --output text)

# Get Redis endpoint  
REDIS_ENDPOINT=$(aws elasticache describe-cache-clusters \
    --cache-cluster-id statuspage-redis \
    --show-cache-node-info \
    --query 'CacheClusters[0].CacheNodes[0].Endpoint.Address' --output text)

# Generate Django secret key
SECRET_KEY=$(python3 -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())')

# Store parameters securely
aws ssm put-parameter --name "/statuspage/prod/db_host" --value "$RDS_ENDPOINT" --type "String"
aws ssm put-parameter --name "/statuspage/prod/db_password" --value "$DB_PASSWORD" --type "SecureString"
aws ssm put-parameter --name "/statuspage/prod/redis_host" --value "$REDIS_ENDPOINT" --type "String"
aws ssm put-parameter --name "/statuspage/prod/secret_key" --value "$SECRET_KEY" --type "SecureString"
aws ssm put-parameter --name "/statuspage/prod/domain_name" --value "yourdomain.com" --type "String"
```

**Checkpoint 2**: Database and cache ready. Cost: $58/month

---

## Phase 3: EC2 Instance and Application (Day 2-3, 4-5 hours)

### Step 3.1: Create IAM Role for EC2
```bash
# Create trust policy
cat > ec2-trust-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "ec2.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
EOF

# Create IAM role
aws iam create-role \
    --role-name StatusPageEC2Role \
    --assume-role-policy-document file://ec2-trust-policy.json

# Create policy for SSM and S3 access
cat > ec2-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "ssm:GetParameter",
                "ssm:GetParameters",
                "ssm:GetParametersByPath"
            ],
            "Resource": "arn:aws:ssm:us-east-1:*:parameter/statuspage/*"
        },
        {
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:PutObject",
                "s3:DeleteObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::statuspage-static-*",
                "arn:aws:s3:::statuspage-static-*/*"
            ]
        }
    ]
}
EOF

aws iam put-role-policy \
    --role-name StatusPageEC2Role \
    --policy-name StatusPagePolicy \
    --policy-document file://ec2-policy.json

# Attach SSM managed policy
aws iam attach-role-policy \
    --role-name StatusPageEC2Role \
    --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore

# Create instance profile
aws iam create-instance-profile --instance-profile-name StatusPageInstanceProfile
aws iam add-role-to-instance-profile \
    --instance-profile-name StatusPageInstanceProfile \
    --role-name StatusPageEC2Role
```

### Step 3.2: Create User Data Script
```bash
cat > user-data-script.sh << 'EOF'
#!/bin/bash
yum update -y

# Install required packages
dnf install -y python3 python3-pip python3-devel gcc \
    libxml2-devel libxslt-devel libffi-devel postgresql-devel \
    openssl-devel nginx git

# Enable and start nginx
systemctl enable nginx
systemctl start nginx

# Create status-page user
groupadd --system status-page
useradd --system -g status-page status-page

# Create directories
mkdir -p /opt/status-page
chown status-page:status-page /opt/status-page

# Install AWS CLI v2
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
./aws/install
rm -rf awscliv2.zip aws/

# Set up Python virtual environment
cd /opt/status-page
python3 -m venv venv
chown -R status-page:status-page venv

# Create basic nginx config
cat > /etc/nginx/conf.d/statuspage.conf << 'NGINX_EOF'
server {
    listen 80;
    server_name _;
    
    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
NGINX_EOF

systemctl restart nginx
EOF
```

### Step 3.3: Launch EC2 Instance
```bash
# Create key pair (optional, we'll use Session Manager)
aws ec2 create-key-pair \
    --key-name statuspage-key \
    --query 'KeyMaterial' --output text > statuspage-key.pem
chmod 400 statuspage-key.pem

# Launch EC2 instance
EC2_INSTANCE_ID=$(aws ec2 run-instances \
    --image-id ami-0230bd60aa48260c6 \
    --instance-type t3.small \
    --key-name statuspage-key \
    --security-group-ids $EC2_SG_ID \
    --subnet-id $PRIVATE_SUBNET_1_ID \
    --iam-instance-profile Name=StatusPageInstanceProfile \
    --user-data file://user-data-script.sh \
    --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=StatusPage-Instance}]" \
    --query 'Instances[0].InstanceId' --output text)
echo "EC2 Instance ID: $EC2_INSTANCE_ID"

# Wait for instance to be running
aws ec2 wait instance-running --instance-ids $EC2_INSTANCE_ID
```

### Step 3.4: Deploy Application Code
```bash
# Connect to instance using Session Manager (no SSH needed)
aws ssm start-session --target $EC2_INSTANCE_ID

# Once connected to the instance, run these commands:
sudo su - status-page
cd /opt/status-page

# Clone or upload your Status Page application code here
# For this example, we'll assume you have the code ready
# git clone https://github.com/yourusername/status-page.git .

# Create AWS configuration file
cat > statuspage/statuspage/aws_config.py << 'EOF'
import boto3
import os

def get_parameter(name):
    ssm = boto3.client('ssm', region_name='us-east-1')
    response = ssm.get_parameter(Name=name, WithDecryption=True)
    return response['Parameter']['Value']

# Database configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'statuspage',
        'USER': 'statuspage_admin',
        'PASSWORD': get_parameter('/statuspage/prod/db_password'),
        'HOST': get_parameter('/statuspage/prod/db_host'),
        'PORT': '5432',
        'CONN_MAX_AGE': 300,
    }
}

# Redis configuration
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://{get_parameter('/statuspage/prod/redis_host')}:6379/1",
    }
}

# Redis for tasks
REDIS = {
    'tasks': {
        'HOST': get_parameter('/statuspage/prod/redis_host'),
        'PORT': 6379,
        'PASSWORD': '',
        'DATABASE': 0,
        'SSL': False,
    },
    'caching': {
        'HOST': get_parameter('/statuspage/prod/redis_host'),
        'PORT': 6379,
        'PASSWORD': '',
        'DATABASE': 1,
        'SSL': False,
    }
}

SECRET_KEY = get_parameter('/statuspage/prod/secret_key')
ALLOWED_HOSTS = [get_parameter('/statuspage/prod/domain_name')]

# S3 Static files configuration (will set up later)
AWS_STORAGE_BUCKET_NAME = get_parameter('/statuspage/prod/s3_bucket')
AWS_S3_REGION_NAME = 'us-east-1'
AWS_DEFAULT_ACL = None
AWS_S3_OBJECT_PARAMETERS = {'CacheControl': 'max-age=86400'}
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
STATICFILES_STORAGE = 'storages.backends.s3boto3.S3StaticStorage'
EOF

# Update main settings.py to import AWS config
echo "from .aws_config import *" >> statuspage/statuspage/settings.py

# Install Python dependencies
source venv/bin/activate
pip install boto3 django-storages[boto3] psycopg2-binary django-redis

# Run the upgrade script (from your original documentation)
sudo /opt/status-page/upgrade.sh

# Create superuser
cd statuspage
python3 manage.py createsuperuser --email admin@yourdomain.com --username admin
```

### Step 3.5: Create Systemd Services
```bash
# Create Gunicorn service
sudo tee /etc/systemd/system/statuspage.service << 'EOF'
[Unit]
Description=Status Page WSGI Service
Wants=network-online.target
After=network-online.target

[Service]
Type=forking
User=status-page
Group=status-page
WorkingDirectory=/opt/status-page
Environment=PATH=/opt/status-page/venv/bin
ExecStart=/opt/status-page/venv/bin/gunicorn --config /opt/status-page/gunicorn.py statuspage.wsgi:application
ExecReload=/bin/kill -s HUP $MAINPID
KillMode=mixed
TimeoutStopSec=5
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF

# Copy gunicorn config
sudo cp /opt/status-page/contrib/gunicorn.py /opt/status-page/gunicorn.py

# Enable and start services
sudo systemctl daemon-reload
sudo systemctl enable statuspage
sudo systemctl start statuspage

# Check status
sudo systemctl status statuspage
```

**Checkpoint 3**: Application running on EC2. Cost: $73/month

---

## Phase 4: Load Balancer and SSL (Day 3, 2 hours)

### Step 4.1: Request SSL Certificate
```bash
# Request certificate from ACM
CERT_ARN=$(aws acm request-certificate \
    --domain-name yourdomain.com \
    --domain-name *.yourdomain.com \
    --validation-method DNS \
    --query 'CertificateArn' --output text)
echo "Certificate ARN: $CERT_ARN"

# Get DNS validation records
aws acm describe-certificate --certificate-arn $CERT_ARN \
    --query 'Certificate.DomainValidationOptions[*].[DomainName,ResourceRecord.Name,ResourceRecord.Value]' \
    --output table

# Add the CNAME records to Route 53 (replace with your hosted zone ID)
HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name \
    --dns-name yourdomain.com \
    --query 'HostedZones[0].Id' --output text | cut -d'/' -f3)

# Create DNS validation record (repeat for each domain)
cat > cert-validation.json << EOF
{
    "Changes": [{
        "Action": "CREATE",
        "ResourceRecordSet": {
            "Name": "_validation_record_name_from_above",
            "Type": "CNAME",
            "TTL": 300,
            "ResourceRecords": [{"Value": "_validation_record_value_from_above"}]
        }
    }]
}
EOF

aws route53 change-resource-record-sets \
    --hosted-zone-id $HOSTED_ZONE_ID \
    --change-batch file://cert-validation.json

# Wait for certificate validation
aws acm wait certificate-validated --certificate-arn $CERT_ARN
```

### Step 4.2: Create Application Load Balancer
```bash
# Create ALB
ALB_ARN=$(aws elbv2 create-load-balancer \
    --name StatusPage-ALB \
    --subnets $PUBLIC_SUBNET_ID $PRIVATE_SUBNET_2_ID \
    --security-groups $ALB_SG_ID \
    --tags Key=Name,Value=StatusPage-ALB \
    --query 'LoadBalancers[0].LoadBalancerArn' --output text)
echo "ALB ARN: $ALB_ARN"

# Get ALB DNS name
ALB_DNS=$(aws elbv2 describe-load-balancers \
    --load-balancer-arns $ALB_ARN \
    --query 'LoadBalancers[0].DNSName' --output text)
echo "ALB DNS: $ALB_DNS"

# Create Target Group
TARGET_GROUP_ARN=$(aws elbv2 create-target-group \
    --name StatusPage-TG \
    --protocol HTTP \
    --port 8000 \
    --vpc-id $VPC_ID \
    --health-check-path /admin/ \
    --health-check-protocol HTTP \
    --health-check-interval-seconds 30 \
    --healthy-threshold-count 2 \
    --unhealthy-threshold-count 5 \
    --query 'TargetGroups[0].TargetGroupArn' --output text)
echo "Target Group ARN: $TARGET_GROUP_ARN"

# Register EC2 instance with target group
aws elbv2 register-targets \
    --target-group-arn $TARGET_GROUP_ARN \
    --targets Id=$EC2_INSTANCE_ID

# Create HTTP listener (redirects to HTTPS)
aws elbv2 create-listener \
    --load-balancer-arn $ALB_ARN \
    --protocol HTTP \
    --port 80 \
    --default-actions Type=redirect,RedirectConfig='{Protocol=HTTPS,Port=443,StatusCode=HTTP_301}'

# Create HTTPS listener
aws elbv2 create-listener \
    --load-balancer-arn $ALB_ARN \
    --protocol HTTPS \
    --port 443 \
    --certificates CertificateArn=$CERT_ARN \
    --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN
```

### Step 4.3: Update Route 53 DNS
```bash
# Create alias record pointing to ALB
cat > dns-record.json << EOF
{
    "Changes": [{
        "Action": "UPSERT",
        "ResourceRecordSet": {
            "Name": "yourdomain.com",
            "Type": "A",
            "AliasTarget": {
                "DNSName": "$ALB_DNS",
                "EvaluateTargetHealth": true,
                "HostedZoneId": "Z35SXDOTRQ7X7K"
            }
        }
    }]
}
EOF

aws route53 change-resource-record-sets \
    --hosted-zone-id $HOSTED_ZONE_ID \
    --change-batch file://dns-record.json
```

**Checkpoint 4**: HTTPS site accessible. Cost: $91/month

---

## Phase 5: S3 and CloudFront (Day 3, 1 hour)

### Step 5.1: Create S3 Bucket
```bash
# Create unique bucket name
BUCKET_NAME="statuspage-static-$(date +%s)"
aws s3 mb s3://$BUCKET_NAME

# Store bucket name in Parameter Store
aws ssm put-parameter \
    --name "/statuspage/prod/s3_bucket" \
    --value "$BUCKET_NAME" \
    --type "String"

# Configure bucket policy
cat > s3-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [{
        "Effect": "Allow",
        "Principal": {
            "AWS": "arn:aws:iam::ACCOUNT_ID:role/StatusPageEC2Role"
        },
        "Action": [
            "s3:GetObject",
            "s3:PutObject",
            "s3:DeleteObject"
        ],
        "Resource": "arn:aws:s3:::$BUCKET_NAME/*"
    }]
}
EOF

# Replace ACCOUNT_ID
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
sed -i "s/ACCOUNT_ID/$ACCOUNT_ID/g" s3-policy.json

aws s3api put-bucket-policy \
    --bucket $BUCKET_NAME \
    --policy file://s3-policy.json

# Upload static files
aws ssm start-session --target $EC2_INSTANCE_ID
# In the session:
cd /opt/status-page/statuspage
source /opt/status-page/venv/bin/activate
python3 manage.py collectstatic --noinput
```

### Step 5.2: Create CloudFront Distribution
```bash
cat > cloudfront-config.json << EOF
{
    "CallerReference": "statuspage-$(date +%s)",
    "Comment": "StatusPage CDN",
    "DefaultRootObject": "index.html",
    "Origins": {
        "Quantity": 1,
        "Items": [{
            "Id": "S3-$BUCKET_NAME",
            "DomainName": "$BUCKET_NAME.s3.amazonaws.com",
            "S3OriginConfig": {
                "OriginAccessIdentity": ""
            }
        }]
    },
    "DefaultCacheBehavior": {
        "TargetOriginId": "S3-$BUCKET_NAME",
        "ViewerProtocolPolicy": "redirect-to-https",
        "MinTTL": 0,
        "ForwardedValues": {
            "QueryString": false,
            "Cookies": {"Forward": "none"}
        },
        "TrustedSigners": {
            "Enabled": false,
            "Quantity": 0
        }
    },
    "Enabled": true,
    "PriceClass": "PriceClass_100"
}
EOF

aws cloudfront create-distribution \
    --distribution-config file://cloudfront-config.json
```

**Checkpoint 5**: CDN configured. Cost: $106/month

---

## Phase 6: Auto Scaling and High Availability (Day 4, 1 hour)

### Step 6.1: Create AMI from Running Instance
```bash
# Create AMI
AMI_ID=$(aws ec2 create-image \
    --instance-id $EC2_INSTANCE_ID \
    --name "StatusPage-AMI-$(date +%Y%m%d)" \
    --description "StatusPage Application AMI" \
    --no-reboot \
    --query 'ImageId' --output text)
echo "AMI ID: $AMI_ID"

# Wait for AMI to be available
aws ec2 wait image-available --image-ids $AMI_ID
```

### Step 6.2: Create Launch Template
```bash
cat > launch-template.json << EOF
{
    "LaunchTemplateName": "StatusPage-LaunchTemplate",
    "LaunchTemplateData": {
        "ImageId": "$AMI_ID",
        "InstanceType": "t3.small",
        "SecurityGroupIds": ["$EC2_SG_ID"],
        "IamInstanceProfile": {
            "Name": "StatusPageInstanceProfile"
        },
        "UserData": "$(base64 -w 0 user-data-script.sh)",
        "TagSpecifications": [{
            "ResourceType": "instance",
            "Tags": [{
                "Key": "Name",
                "Value": "StatusPage-ASG-Instance"
            }]
        }]
    }
}
EOF

aws ec2 create-launch-template --cli-input-json file://launch-template.json
```

### Step 6.3: Create Auto Scaling Group
```bash
aws autoscaling create-auto-scaling-group \
    --auto-scaling-group-name StatusPage-ASG \
    --launch-template LaunchTemplateName=StatusPage-LaunchTemplate,Version='$Latest' \
    --min-size 1 \
    --max-size 3 \
    --desired-capacity 1 \
    --target-group-arns $TARGET_GROUP_ARN \
    --health-check-type ELB \
    --health-check-grace-period 300 \
    --vpc-zone-identifier "$PRIVATE_SUBNET_1_ID,$PRIVATE_SUBNET_2_ID" \
    --tags "Key=Name,Value=StatusPage-ASG,PropagateAtLaunch=true"

# Create scaling policies
SCALE_UP_POLICY=$(aws autoscaling put-scaling-policy \
    --auto-scaling-group-name StatusPage-ASG \
    --policy-name StatusPage-ScaleUp \
    --policy-type TargetTrackingScaling \
    --target-tracking-configuration file://scale-up-policy.json \
    --query 'PolicyARN' --output text)

cat > scale-up-policy.json << EOF
{
    "TargetValue": 70.0,
    "PredefinedMetricSpecification": {
        "PredefinedMetricType": "ASGAverageCPUUtilization"
    }
}
EOF
```

**Checkpoint 6**: Auto Scaling configured. Cost: $106/month (same, just more reliable)

---

## Phase 7: Monitoring and Security (Day 4, 2 hours)

### Step 7.1: CloudWatch Alarms
```bash
# High CPU Alarm
aws cloudwatch put-metric-alarm \
    --alarm-name "StatusPage-HighCPU" \
    --alarm-description "StatusPage CPU above 80%" \
    --metric-name CPUUtilization \
    --namespace AWS/EC2 \
    --statistic Average \
    --period 300 \
    --threshold 80 \
    --comparison-operator GreaterThanThreshold \
    --evaluation-periods 2 \
    --alarm-actions "arn:aws:sns:us-east-1:ACCOUNT_ID:alerts"

# RDS Connection Alarm
aws cloudwatch put-metric-alarm \
    --alarm-name "StatusPage-DB-HighConnections" \
    --alarm-description "RDS high connection count" \
    --metric-name DatabaseConnections \
    --namespace AWS/RDS \
    --statistic Average \
    --period 300 \
    --threshold 15 \
    --comparison-operator GreaterThanThreshold \
    --dimensions Name=DBInstanceIdentifier,Value=statuspage-db

# ALB Error Rate Alarm
aws cloudwatch put-metric-alarm \
    --alarm-name "StatusPage-ALB-Errors" \
    --alarm-description "ALB high error rate" \
    --metric-name HTTPCode_Target_5XX_Count \
    --namespace AWS/ApplicationELB \
    --statistic Sum \
    --period 300 \
    --threshold 10 \
    --comparison-operator GreaterThanThreshold
```

### Step 7.2: AWS WAF Configuration
```bash
# Create WAF Web ACL
WAF_ACL_ARN=$(aws wafv2 create-web-acl \
    --name StatusPage-WAF \
    --scope REGIONAL \
    --default-action Allow={} \
    --rules file://waf-rules.json \
    --query 'Summary.ARN' --output text)

cat > waf-rules.json << EOF
[
    {
        "Name": "AWSManagedRulesCommonRuleSet",
        "Priority": 1,
        "OverrideAction": {"None": {}},
        "Statement": {
            "ManagedRuleGroupStatement": {
                "VendorName": "AWS",
                "Name": "AWSManagedRulesCommonRuleSet"
            }
        },
        "VisibilityConfig": {
            "SampledRequestsEnabled": true,
            "CloudWatchMetricsEnabled": true,
            "MetricName": "CommonRuleSetMetric"
        }
    }
]
EOF

# Associate WAF with ALB
aws wafv2 associate-web-acl \
    --web-acl-arn $WAF_ACL_ARN \
    --resource-arn $ALB_ARN
```

### Step 7.3: AWS Backup
```bash
# Create backup vault
aws backup create-backup-vault \
    --backup-vault-name StatusPage-Backup \
    --encryption-key-arn alias/aws/backup

# Create backup plan
cat > backup-plan.json << EOF
{
    "BackupPlanName": "StatusPage-BackupPlan",
    "Rules": [{
        "RuleName": "DailyBackups",
        "TargetBackupVaultName": "StatusPage-Backup",
        "ScheduleExpression": "cron(0 3 ? * * *)",
        "Lifecycle": {
            "DeleteAfterDays": 7
        },
        "RecoveryPointTags": {
            "Project": "StatusPage"
        }
    }]
}
EOF

BACKUP_PLAN_ID=$(aws backup create-backup-plan \
    --backup-plan file://backup-plan.json \
    --query 'BackupPlanId' --output text)

# Create backup selection
cat > backup-selection.json << EOF
{
    "BackupSelectionName": "StatusPage-Selection",
    "IamRoleArn": "arn:aws:iam::$ACCOUNT_ID:role/aws-service-role/backup.amazonaws.com/AWSServiceRoleForBackup",
    "Resources": [
        "arn:aws:ec2:us-east-1:$ACCOUNT_ID:instance/$EC2_INSTANCE_ID",
        "arn:aws:rds:us-east-1:$ACCOUNT_ID:db:statuspage-db"
    ]
}
EOF

aws backup create-backup-selection \
    --backup-plan-id $BACKUP_PLAN_ID \
    --backup-selection file://backup-selection.json
```

**Checkpoint 7**: Full monitoring and security. Cost: $131/month

---

## Phase 8: CI/CD Pipeline (Day 5, 3 hours)

### Step 8.1: Create CodeCommit Repository
```bash
aws codecommit create-repository \
    --repository-name statuspage \
    --repository-description "StatusPage Application Code"

# Get clone URL
REPO_URL=$(aws codecommit get-repository \
    --repository-name statuspage \
    --query 'repositoryMetadata.cloneUrlHttp' --output text)
echo "Repository URL: $REPO_URL"
```

### Step 8.2: Create CodeBuild Project
```bash
cat > buildspec.yml << EOF
version: 0.2
phases:
  install:
    runtime-versions:
      python: 3.9
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - pip install -r requirements.txt
      - python manage.py test
  build:
    commands:
      - echo Build started on \`date\`
      - python manage.py collectstatic --noinput
  post_build:
    commands:
      - echo Build completed on \`date\`
      - aws s3 sync staticfiles/ s3://\$S3_BUCKET/static/ --delete
artifacts:
  files:
    - '**/*'
  base-directory: '.'
EOF

# Create service role for CodeBuild
aws iam create-role \
    --role-name CodeBuildServiceRole \
    --assume-role-policy-document file://codebuild-trust.json

cat > codebuild-trust.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [{
        "Effect": "Allow",
        "Principal": {"Service": "codebuild.amazonaws.com"},
        "Action": "sts:AssumeRole"
    }]
}
EOF

# Create CodeBuild project
aws codebuild create-project \
    --name statuspage-build \
    --source type=CODECOMMIT,location=$REPO_URL \
    --artifacts type=S3,location=statuspage-artifacts-$ACCOUNT_ID \
    --environment type=LINUX_CONTAINER,image=aws/codebuild/amazonlinux2-x86_64-standard:3.0,computeType=BUILD_GENERAL1_SMALL \
    --service-role arn:aws:iam::$ACCOUNT_ID:role/CodeBuildServiceRole
```

### Step 8.3: Create CodeDeploy Application
```bash
# Create CodeDeploy application
aws deploy create-application \
    --application-name StatusPage-App \
    --compute-platform Server

# Create deployment group
aws deploy create-deployment-group \
    --application-name StatusPage-App \
    --deployment-group-name Production \
    --service-role-arn arn:aws:iam::$ACCOUNT_ID:role/CodeDeployServiceRole \
    --auto-scaling-groups StatusPage-ASG \
    --load-balancer-info targetGroupInfoList=[{name=StatusPage-TG}]
```

**Checkpoint 8**: CI/CD Pipeline ready. Cost: $141/month

---

## Phase 9: Final Testing and Go Live (Day 5, 1 hour)

### Step 9.1: System Testing Checklist
```bash
# Test HTTPS access
curl -I https://yourdomain.com

# Test health endpoint
curl https://yourdomain.com/admin/

# Test load balancer health
aws elbv2 describe-target-health --target-group-arn $TARGET_GROUP_ARN

# Test auto scaling (simulate high load)
aws autoscaling set-desired-capacity \
    --auto-scaling-group-name StatusPage-ASG \
    --desired-capacity 2

# Test failover (terminate instance)
aws ec2 terminate-instances --instance-ids $EC2_INSTANCE_ID
```

### Step 9.2: Security Verification
- [ ] All EC2 instances in private subnets
- [ ] Database accessible only from application servers
- [ ] SSL certificate properly configured
- [ ] WAF rules active and logging
- [ ] Security groups following least privilege
- [ ] CloudTrail logging enabled
- [ ] No hardcoded credentials in code

### Step 9.3: Performance Baseline
- [ ] Page load time < 2 seconds
- [ ] Database query time < 100ms
- [ ] CDN cache hit ratio > 80%
- [ ] SSL handshake time < 500ms

---

## Cost Summary

| Environment | Monthly Cost |
|-------------|--------------|
| Production | $136.50 |
| Development | $35.00 |
| CI/CD & DevOps | $30.00 |
| Buffer | $98.50 |
| **Total** | **$300.00** |

## Optimization Recommendations

### Immediate (Month 1-3)
- Monitor actual usage patterns
- Adjust instance sizes based on real load
- Implement S3 Intelligent Tiering
- Schedule development environment shutdown

### Medium Term (Month 6)
- Purchase Reserved Instances (30% savings)
- Implement auto-scaling policies
- Add read replicas if needed
- Consider multi-region setup

### Long Term (Year 1+)
- Move to containerized deployment (ECS/EKS)
- Implement microservices architecture
- Add CDN edge locations
- Consider Savings Plans for compute

---

## Troubleshooting Guide

### Common Issues
1. **ALB Health Check Failing**
   - Check security group rules
   - Verify application is running on port 8000
   - Check health check endpoint

2. **Database Connection Issues**
   - Verify RDS security group allows EC2 access
   - Check connection strings in Parameter Store
   - Verify RDS is in available state

3. **SSL Certificate Issues**
   - Ensure DNS validation records are correct
   - Wait for certificate validation (can take 30+ minutes)
   - Check domain ownership

4. **Auto Scaling Not Working**
   - Verify launch template is correct
   - Check IAM permissions for Auto Scaling
   - Review CloudWatch alarms

### Monitoring Commands
```bash
# Check instance status
aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID

# Check RDS status
aws rds describe-db-instances --db-instance-identifier statuspage-db

# Check ALB status
aws elbv2 describe-target-health --target-group-arn $TARGET_GROUP_ARN

# Check Auto Scaling Group
aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names StatusPage-ASG
```

This implementation guide provides a complete step-by-step process to deploy a production-ready Status Page application on AWS within the $300/month budget.
